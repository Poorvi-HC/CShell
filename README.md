# Project: Building a C-Shell from Scratch

This repository contains the codebase written completely in C for building a C-shell from scratch. Please feel free to clone the repository to try out the code. Issues and pull requests are encouraged. Possible extensions to the codebase can be:
- Implementation of new commands
- Improving efficiency or optimizing the existing implementation
- Possible extensions can be to eliminate the assumptions (made during initial implementation) and handle all edge cases.

## Modular code:
### Directory structure:
    - src
        - definitions.h
        - cshell.c (main.c file)
        - utilities.h
        - utilities.c
        - commands
            - *.c
            - *.h
    - MakeFile
    - README.md
* `src` directory that has all the `.c` and `.h` files that have all the source code for the shell.
* `Makefile` contains the linking and compiling instructions to make the shell executable.
* `README.md` contains the all implementation details and assumptions for this shell
* `cshell` is the compiled shell executable

## How to run the shell:

1. clone the repository
1. enter the CSHELL folder
1. Run the below commands

```
    $ make all
    $ ./cshell
```

### File Descriptions
Description of each of the files inside the `src` directory:

1. `cshell.c` → Contains the main function for the shell. Is essentially just the infinite loop that keeps the shell running. Also has some global variables that need to be used across different `.c` files.

2. `defitions.h` → Contains all the library header files, custom `#define` macros used across all the `.c` files as well as the definiton of a custom `struct`.

3. `commands/*.c` → Contains all the functions required to implement the behvaiour of the specified commands.

4. `commands/*.h` → Header file for `commands/*.c`.

5. `utilites.c` → Contains all the shell and command related utility functions.

6. `utilities.h` → Header file for `utilities.h`.

### General Implementation Details
When the shell is run, for each input, the general stack trace looks something like this:

1. The `main` function contains an infinite loop responsible for generating the prompt string using `generatePString()` from utilities.c and handling user input commands.
2. The input is split into `;` seperated command by passing the input string to `processInputString()` in `utilities.c`.
3. Each `;` seperated command is then sent to `process_amp()` to tokenize based on `&`, further each token is passed into `processCommand()` in `utilites.c` to get rid of extra whitespaces in the command.
4. The argument seperated commands are then passed to the `managePipes()` function which tokenizes based on '|' (pipe).
5. Each cleaned and piped tokenized command is then sent to `execCommand()` in `utilites.c` which inturn recognizes the keyword in the given command, and then calls the `run` function corresponding to that keyword from `commands/*.c`.
6. Certain command functions are dependent on other functions. Depending on the nature of these functions, they may either belong to `commands/*.c` or `utilities.c`.

### Specification Implementation Details

#### Specification 1: Prompt String

The prompt string is generated by the `generatePS()` method in `utilities.c`. The Prompt string consists of 3 parts.
1. The name of the user. An instance of `struct passwd` is populated with the current user's details using `getpwuid(getuid())`. The current user's name is in `passwd->pw_name`.
2. The hostname of the system. Copied into a buffer using the `gethostname()` method.
3. The current working directory of the shell. Copied into a buffer using the `getcwd()` method. If it is the first time `generatePS()` has been called, it means that our current working directory is also the shell invocation location. This value is saved in a global variable, and is defined as `~` for the running instance of the shell.

*Important: If any of the above functions fail, the prompt string cannot be generated, and the shell **exits abnormally** due to potentially insufficient run-time permissions.*

#### Specification 2: `peek` command
Implemented in `commands/peek.c`. 
1. Assign a pointer to each argument in the command.
2. Iterate over the pointers and identify the flags. Set `lFlag` and `aFlag` as required.
3. For every argument that is a directory:
    * Create an array of 7 integers, that store the maximum number of characters in a column (there are 7 colums).
    * Open a link to the directory using `opendir()` and save this link in an instance of `DIR*`.
    * Make an instance of `dirent` and use it to iterate over each child of the given directory, using `readdir()`.
    * For each child of the directory, if `lflag` is set, populate and instance of `struct stat` with the child's information using `lstat`. Get the max between the current max column size and the current file's column size for each column. Also accumulate its `st_blocks` value to print `total` later.
    * Now, close and reopen the link to the required directory to reset the pointer location, print the `total` value and again iterate over each child of the directory, printing the required details (just the name is `lFlag` is not set, and all details is `lFlag` is set). If `lFlag` is set, the `ls_printFileDetails()` is called from `commands/peek.c` (which inturn calls `ls_printPermissions()` from `commands/peek.c` to convert the `mode_t` permission bits into the Linux formatted permission string and print it), which handles all the padding (using the array populated from the previous loop over the children) and information printing. The link to the directory is closed again.

#### Specification 3: `warp` command
Implemented in `commands/warp.c`
`warp` command changes the directory that the shell is currently in. It should also print the full path of working directory after changing. The directory path/name can be provided as argument to this command.
1. The `warp` function first copies the input argument into a new buffer, considering various scenarios.  The function then extracts the username, handles special cases like "~" and "-", and manages the current and previous working directories.
2. Through conditional statements, the function navigates the directory structure based on the provided path, including handling ".", "..", and absolute paths. It employs logical checks to determine the appropriate actions for each case, ensuring accurate movement within the file system.
3. The function prints the resulting path to the console, providing informative feedback to the user. In case of errors, such as attempting to navigate to an invalid location, it sets an exit code and retains the previous working directory. The exit code can be used for further error handling in the shell environment.

#### Specification 4: System commands
Implemented in `commands/system.c`.
1. The shell distinguishes between foreground and background execution of system commands. For foreground processes, it waits for the completion of the command, and if the process takes more than 2 seconds, the shell prints the time and process name in the next prompt. Background processes, invoked with "&," are spawned without handing control of the terminal to them. The shell continues to take user commands while printing the PID of the newly created background process.
2. The `bExec()` and `fExec()` methods in `commands/system.c` handle background and foreground execution, respectively. Arguments, separated by spaces, are processed, and relative paths to ~ are expanded to absolute paths. The shell uses` fork()` to create a child process and utilizes `execvp()` to load a new executable image onto the child process. In the case of background execution, the child's process group is changed to send it to the background.
3. Error messages are displayed if `execvp()` fails, providing information about the command. In foreground execution, the shell waits for the child process to exit and reclaims resources using `wait()`. For background execution, the child process is inserted into a child pool, facilitating the management of background processes. This allows the shell to continue taking user commands without waiting for background processes to complete.

#### Specification 5: `proclore` command
1. The `proclore` function retrieves information about a specified process or the current process (if no arguments provided). It reads the contents of `/proc/<pid>/stat`, where pid is either provided or obtained using `getpid()`. The information includes **process status, process group, virtual memory, and executable path**.
2. The function determines if the process is in the foreground by comparing its process group ID with its PID. If it is a foreground process, a "+" is appended to the process status. This distinction is crucial for recognizing foreground and background processes.
3. The function reads the symbolic link at `/proc/<pid>/exe` to obtain the path of the executable. If the process is a `zombie` process, the executable path is marked as "Doesn't exist," as the link won't be present in such cases. The obtained executable path is then shortened using `shortenPathSubDir` for better readability in the output.

#### Specification 6: Finished Background Processes

The way this shell has been implemented, sets a cap on the maximum number of child processes that it can have running simultaneously to 512. A custom structure, `struct pData`, defined in `definitions.h`, stores a process pid and corresponding name. We initilize an array of 512 such stuctures and set all their pids to `-1` using the `initChildren()` method in `utilities.c`, indicating that that particular process is empty. This array is referred to as the **child pool**.

In `main()`, one of the first things we do is install a signal handler using the `installHandler()` method defined in `utilities.c`, that will run each time a `SIGCHLD` signal is sent to the shell. This is done using an instance of `struct sigaction`. *Note that no extra functionality that is provided by `sigaction` but not `signal()` has been used. `sigaction` has been chosen because it is the newer, and arguably better approach to define custom signal handlers.*

When a new background process is created, it is first checked that current number of child processes is less than the maximum limit. If not, the child process is not created and an error is shown. Otherwise, we fill the pid and process name in the first empty location in the array.

When a background process is terminated, the handler is called. Within the handler, we loop over all the children who have exited since the shell recieved the SIGCHLD signal, using `waitpid()`. By default `waitpid()` is blocking, which is not desirable in this situation, so we make use of the `WNOHANG` flag to make it non-blocking. For each pid that we get from `waitpid()`, we look for it in the child pool, and get its name by matching its pid. We print the termination message with the name and pid of the process and "normally" or "abnormally" depending on the exit status of the process. We then replace the pid of that element in the array with `-1` to indicate that that position in the pool is free to be occupied by another child process.

Finally, the prompt string is printed again as an aesthetic feature.


#### Specification 6: `fg` and `bg` command
* `exit` → Simply exits from the shell. Doesn't handle child process termination.
* `fg <job number>` -> Implemented in `fg()` in `commands/fg.c`. Checks command usage, then verifies the given job number. Once it is confirmed that the job is a valid one, it gets its pid from the child pool, gets its process group, removes the child from the pool, tells the shell to ignore all `STDIN` and `STDOUT` related events and then gives terminal control to the process group belonging to said job. The job is also sent the `SIGCONT` signal, incase it had stopped in the background. While the process runs in the foreground, the shell waits on it using the `wait()` syscall. Once the foreground process terminates or has been stopped, the terminal control is returned to the shell and the default response to `STDIN` and `STDOUT` events is restored.
* `bg <job number>`-> Implemented in `bg()` in `commands/bg.c`. Checks command usage, then verifies the given job number. Once it is confirmed that the job is a valid one, it gets its pid from the child pool. Then it sends the `SIGCONT` signal to that process using the `kill()` method, to tell it to change its status from stopped to running.

#### Specification 7: Signal Handling 

For both the signals, a new action was defined using the `sigaction` structure.

1. `Ctrl-Z`: The hanlder for this is relatively straightforward. It makes a new line and prints the prompt string again. To make sure that when a Ctrl-Z is hit on a foreground process, it is added to the job pool, one bit of modification needed to be made in `fExec()` and `fg()`. The `wait()` was replaced with `waitpid()` and the `WUNTRACED` flag was set. This way, we could inspect the status code to check if the process had been stopped or terminated using the `WIFSTOPPED` macro. If the process has been stopped, it is added to the child pool, because it has been sent to the background.

2. `Ctrl-C`: The hanlder for this is essentially the same as that for the previous one. It prints a new line and prints the prompt string again.

3. `Ctrl-D`: it exits the shell.

#### Specification 8: I/O redirection

The `execCommand()` method in `utilities.c` has been modified to parse the command and check if any kind of I/O redirection is required. If it is, then the required file is opened and the required streams are connected to them. Then the functions corresponding to the command is executed. After returning from the command specific function, at the end of the `execCommand()` function, the files are closed and streams are set to default.

#### Specification 9: Pipelines

A new function has been added in the call stack, called `handlePipes()`, which is called by `cleanCommand()` and inturn calls `execCommand()` to execute it acfter handling piping logic.

Inside `handlePipes()`, we first calculate the number of pipes. If it is 0, we directly send the input string to `execCommand()`. Instead, if there are some pipes, we split to commands. Say there are `n` commands, then we create `n` pipes, meaning `2n` file descriptors and populate them using the `pipe()` function. We then create `n` child processes of the shell. We link the `STDOUT` of the `ith` child to the `ith` write end of the pipe and the `STDIN` of the `ith` child to the `(i-1)th` read end of the pipe. So, the `STDIN` of the first child is still default and the `STDOUT` of the last child is also still default. This creates a pipe chain in which the `ith` child reads the input from the output of the `(i-1)th` child.


#### Specification 10: `pastevents` command
Implemented in `commands/pastevents.c`.
1. The `loadPastEvents` function is responsible for loading command statements into the `HISTORY_ARRAY` based on certain constraints. It avoids storing commands containing the term "pastevents" and prevents storing identical consecutive commands. If the maximum storage limit is reached, it shifts existing commands to make room for new ones.
2. The `savePastEvents` function is invoked to save the contents of `HISTORY_ARRAY` into a file named "history.txt." This file acts as persistent storage, ensuring that the most recent command statements are retained even when the shell is exited. The function also considers the current working directory to handle file operations properly.
3. The `runPastEvents` function interprets and executes various commands related to past events. It distinguishes between "pastevents," "pastevents purge," and "pastevents execute." The corresponding functions, pastevents, pastEventsPurge, and pastEventsExec, handle the execution of these commands. The "pastevents execute" command retrieves and processes a specific command from the history based on the provided index, eventually running it.

#### Specification 10: `seek` command
Implemented in `commands/seek.c`.
1. The `seek` command searches for a file or directory within the specified target directory or the current working directory if none is specified. It returns a list of relative paths for all matching files and directories, with files displayed in green and directories in blue. The search is performed recursively through the target directory's tree.
2. The command supports three flags: `-d` (look for directories only),` -f `(look for files only), and `-e` (execute specific actions when a single file or directory is found). The implementation handles flag validation, and based on the flags, it formats the output accordingly, highlighting file paths in green and directory paths in blue. The -e flag allows reading the contents of a file or changing the current working directory to a found directory, provided the necessary permissions.
3. The `recurse_for_File` function is a recursive function responsible for traversing the directory tree, identifying and printing matching files and directories. It maintains the current path string and appends each directory or file name during recursion. Path resolution is handled to accommodate relative paths, special symbols like '~', and directory navigation symbols ('.', '..', etc.). The recursive search helps cover all nested directories within the specified target directory.

#### Specification 11: `activities` command
Implemented in `commands/activities.c`.
1. The `activities` function prints information about all processes spawned by the shell. It uses a custom data structure (`struct pData`), which likely holds information about each child process, such as its PID (process ID), command, and other details. The child processes are stored in an array (`childArray`), and the function utilizes the` qsort` function to sort this array in lexicographic order based on the PIDs.
2. For each process in the sorted array, the function reads its status from the `/proc/<pid>/stat` file. This file contains various details about the process, and the third attribute in this file provides the process status. The status is then interpreted to determine if the process is running or stopped. If the status indicates 'S', it is considered running; otherwise, it is marked as stopped.
3. Finally, the function prints information about each process, including the PID, command name, and the determined status (running or stopped). The output is formatted to display these details for all processes spawned by the shell. This provides a comprehensive view of the shell's child processes, sorted by PID in lexicographic order.

#### Specification 12: `ping` command
Implemented in `commands/ping.c`.
1. The `ping` command structure is defined as `ping <pid> <signal_number>`. The implementation checks if the command has exactly three arguments: the command itself, the process ID (PID), and the signal number. If the argument count is incorrect, it prints an error message and sets the exit code.
2. The function extracts the PID and signal number from the provided arguments, ensuring they are positive integers. The signal number is then taken modulo 32 to accommodate x86/ARM machines. It checks whether the specified PID exists among the processes spawned by the shell. If the PID is not found, an error message is printed.
3. If the specified PID is found, the function attempts to send the specified signal to the process using the kill system call. It checks for errors during the signal-sending process and prints an appropriate error message if needed. The implementation provides comprehensive error handling to cover scenarios such as invalid arguments, non-existent PIDs, and signaling errors.

#### Specification 13: `neonate` command
Implemented in `commands/neonate.c`.
1. The `neonate` command structure is defined as `neonate -n <time_args>`. The implementation checks if the command has exactly three arguments: the command itself, the flag `-n`, and the time interval (`time_args`). If the argument count is incorrect or the flag is invalid, it prints an error message and sets the exit code.
2. The `enableRawMode` and `disableRawMode` functions are responsible for putting the terminal into raw mode, which turns off canonical mode (line buffering) and echoing. This allows the program to read one character at a time without waiting for a newline. The raw mode is enabled when the `neonate` command is executed and disabled before exiting.
3. The `neonate` function continuously prints the Process-ID (PID) of the most recently created process on the system at intervals specified by `time_args`. It uses a simple keyboard hit detection (`kbhit`) to check if the user has pressed the 'x' key. If 'x' is pressed, the loop breaks, and the function exits. This implementation provides a basic form of process monitoring and user interaction within a time interval.

#### Specification 14: `iMan` command
Implemented in `commands/iman.c`.
1. The `iMan` command structure is defined as `iMan <command>`. The implementation checks if the command has exactly two arguments: the command itself and the specified `<command>` for which the man page is to be fetched. If the argument count is incorrect, it prints an error message and sets the exit code.
2. The implementation uses the `gethostbyname` function to perform DNS resolution for `"man.he.net" `and establishes a `TCP socket` connection. It then constructs an `HTTP GET request` for the specified <command> and sends it to the server. The response is read in chunks, and the body content (man page) is extracted using simple HTML parsing logic, checking for the <body> tag.
3. The parsed content of the man page is printed to the terminal. If the content is successfully extracted, it prints the relevant information from the man page. If there are no matches (as indicated by "No matches" in the response), an appropriate error message is printed. The implementation provides a basic mechanism to fetch and display man pages for the specified commands.

# Assumptions made throughout the project

1. absolute path - with respect to the local system file system
1. relative path - can handle ./, ../, and ~/ alone
1. Command specific
    - For warp
        - absolute paths are wrt local system
        - .. from invocation direcotry moves it to the parent directory of the invocation loc
    - For peek
        - displayed as files and folders in new line
        - color scheme: green for executables, white for files and blue for directories
    - For seek:
        - not lexicographically ordered 
        - color scheme: files in green and directories in blue
        - all error flags needed included
        - shell crashes when searching for some file in the directory
    - For system calls:
        - pid sometimes prints after generation of the Prompt string
        - A new prompt string is generated once the child process running in the background exits/ is killed.
    - For sed:
        - sed doesn't take quotational arguments
    - proclore:
        - no assumptions made
    - pastevents:
        - no assumptions made
    - fg & bg:
        - only stopped processes can resume in bg
        - have handled float and negative numbers alone
    - piping:
        - haven't handled the case where piped commands are placed in the background.
    - neonate:
        - 'x' key when pressed, might have some delay for exiting the command
    - iman:
        - am printing all the manual contents in the shell 
        - some additional html tags aren't handled 
    - activities:
        - prints in lexicographical order of job number
    - ping:
        - no assumptions made

1. Exit shell using "exit" or "quit" command
1. signals - 
    Ctrl-Z -> moves into background
    Ctrl-C -> exits the running foreground process
    Ctrl-D -> exist shell
